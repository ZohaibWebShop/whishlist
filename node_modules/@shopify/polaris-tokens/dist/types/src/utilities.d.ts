import type { Exact, MetadataGroup, Tokens, TokenGroup } from './types';
import type { breakpoints as metaBreakpointsTokenGroup, BreakpointsTokenGroup, BreakpointsTokenName } from './token-groups/breakpoints';
export declare function getUnit(value?: string): string | null;
export declare function toPx(value?: string): string | undefined;
export declare function toEm(value?: string, fontSize?: number): string | undefined;
export declare function toRem(value?: string): string | undefined;
export declare function rem(value: string): string;
export declare function tokensToRems<T extends Exact<MetadataGroup, T>>(tokenGroup: T): T;
export declare function createVar(token: string): string;
/**
 * Allowed Polaris keyframes.
 *
 * Result: ['p-keyframes-fade-in', 'p-keyframes-spin', etc...]
 */
export declare function getKeyframeNames(motionTokenGroup: TokenGroup): (string | null)[];
/**
 * Allowed Polaris token custom properties.
 *
 * Result: ['--p-color-bg-app', '--p-color-text', etc...]
 */
export declare function getCustomPropertyNames(tokens: Tokens): string[];
export declare function removeMetadata<T extends Exact<MetadataGroup, T>>(tokenGroup: T): TokenGroup<T>;
export type MetaBreakpointsTokenGroup = typeof metaBreakpointsTokenGroup;
/**
 * Alias direction used for composing Polaris `breakpoints` utilities.
 */
export type BreakpointsAliasDirection = 'up' | 'down' | 'only';
/**
 * A collection of directional media conditions for a given Polaris `breakpoints` alias.
 */
export type BreakpointsAliasDirectionMediaConditions = {
    [AliasDirection in BreakpointsAliasDirection]: string;
};
/**
 * Media conditions for all Polaris `breakpoints` aliases.
 */
export type BreakpointsMediaConditions = {
    [TokenName in BreakpointsTokenName]: BreakpointsAliasDirectionMediaConditions;
};
export declare function getMediaConditions(breakpoints: BreakpointsTokenGroup): BreakpointsMediaConditions;
export declare function isKeyOf<T extends {
    [key: string]: any;
}>(obj: T, key: PropertyKey | undefined): key is keyof T;
/**
 * Identity function creator that returns the provided input,
 * but additionally validates the input matches the type exactly
 * and infers all members.
 *
 * TODO: Replace all instances with `satisfies` when we upgrade
 * to TypeScript >=4.9
 *
 * @example
 * ```
 * type ExampleShape = { [key: string]: string }
 * const createExample = createExact<ExampleShape>()
 *
 * const example = createExample({
 *  foo: 'bar',
 * })
 * ```
 *
 * Where `typeof example` is inferred as `{ foo: string }`
 */
export declare function createExact<T extends object>(): <U extends Exact<T, U>>(obj: U) => U;
//# sourceMappingURL=utilities.d.ts.map
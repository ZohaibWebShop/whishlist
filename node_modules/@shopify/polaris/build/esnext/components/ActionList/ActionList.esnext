import React, { useRef, useState, useMemo } from 'react';
import { Key } from '../../types.esnext';
import { wrapFocusPreviousFocusableMenuItem, wrapFocusNextFocusableMenuItem } from '../../utilities/focus.esnext';
import { Section } from './components/Section/Section.esnext';
import { SearchField } from './components/SearchField/SearchField.esnext';
import { useI18n } from '../../utilities/i18n/hooks.esnext';
import { KeypressListener } from '../KeypressListener/KeypressListener.esnext';
import { Box } from '../Box/Box.esnext';
import { Item } from './components/Item/Item.esnext';

function ActionList({
  items,
  sections = [],
  actionRole,
  onActionAnyItem
}) {
  const i18n = useI18n();
  let finalSections = [];
  const actionListRef = useRef(null);
  const [searchText, setSeachText] = useState('');
  if (items) {
    finalSections = [{
      items
    }, ...sections];
  } else if (sections) {
    finalSections = sections;
  }
  const isFilterable = finalSections?.some(section => section.items.some(item => typeof item.content === 'string'));
  const hasMultipleSections = finalSections.length > 1;
  const elementRole = hasMultipleSections && actionRole === 'menuitem' ? 'menu' : undefined;
  const elementTabIndex = hasMultipleSections && actionRole === 'menuitem' ? -1 : undefined;
  const filteredSections = finalSections?.map(section => ({
    ...section,
    items: section.items.filter(({
      content
    }) => typeof content === 'string' ? content?.toLowerCase().includes(searchText.toLowerCase()) : content)
  }));
  const sectionMarkup = filteredSections.map((section, index) => {
    return section.items.length > 0 ? /*#__PURE__*/React.createElement(Section, {
      key: typeof section.title === 'string' ? section.title : index,
      section: section,
      hasMultipleSections: hasMultipleSections,
      actionRole: actionRole,
      onActionAnyItem: onActionAnyItem,
      isFirst: index === 0
    }) : null;
  });
  const handleFocusPreviousItem = evt => {
    evt.preventDefault();
    if (actionListRef.current && evt.target) {
      if (actionListRef.current.contains(evt.target)) {
        wrapFocusPreviousFocusableMenuItem(actionListRef.current, evt.target);
      }
    }
  };
  const handleFocusNextItem = evt => {
    evt.preventDefault();
    if (actionListRef.current && evt.target) {
      if (actionListRef.current.contains(evt.target)) {
        wrapFocusNextFocusableMenuItem(actionListRef.current, evt.target);
      }
    }
  };
  const listeners = actionRole === 'menuitem' ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(KeypressListener, {
    keyEvent: "keydown",
    keyCode: Key.DownArrow,
    handler: handleFocusNextItem
  }), /*#__PURE__*/React.createElement(KeypressListener, {
    keyEvent: "keydown",
    keyCode: Key.UpArrow,
    handler: handleFocusPreviousItem
  })) : null;
  const totalActions = finalSections?.reduce((acc, section) => acc + section.items.length, 0) || 0;
  const totalFilteredActions = useMemo(() => {
    const totalSectionItems = filteredSections?.reduce((acc, section) => acc + section.items.length, 0) || 0;
    return totalSectionItems;
  }, [filteredSections]);
  const showSearch = totalActions >= 8;
  return /*#__PURE__*/React.createElement(React.Fragment, null, showSearch && isFilterable && /*#__PURE__*/React.createElement(Box, {
    padding: "2",
    paddingBlockEnd: totalFilteredActions > 0 ? '0' : '2'
  }, /*#__PURE__*/React.createElement(SearchField, {
    placeholder: i18n.translate('Polaris.ActionList.SearchField.placeholder'),
    value: searchText,
    onChange: value => setSeachText(value)
  })), /*#__PURE__*/React.createElement(Box, {
    as: hasMultipleSections ? 'ul' : 'div',
    ref: actionListRef,
    role: elementRole,
    tabIndex: elementTabIndex
  }, listeners, sectionMarkup));
}
ActionList.Item = Item;

export { ActionList };
